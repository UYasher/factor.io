module GraphUtils where

import Blueprint
import Data.Map as Map
import Data.Maybe as Maybe
import Data.Set as Set
import Geometry
import Machine
import Wire

-- | `Graph` represents an unweighted, directed graph with no parallel edges
-- as a map from a node to its outNeighbors
newtype Graph = Graph (Map.Map Int (Set Int)) deriving (Show, Eq)

-- | Covert a point on a blueprint to a unique node in a graph
pointToInt :: Blueprint -> Point -> Int
pointToInt Blueprint {width = w} Point {pointX = x, pointY = y} = x + y * w

-- | Covert a node in a graph to a point on the given blueprint
intToPoint :: Blueprint -> Int -> Point
intToPoint Blueprint {width = w} n = Point (n `safeMod` w) (n `div` w)
  where
    safeMod m d = if d == 0 then 0 else m `mod` d

adjacentPoints :: Blueprint -> Point -> [Point]
adjacentPoints b p = Prelude.filter (`isInBounds` b) [p +>> Point 0 1, p +>> Point 1 0, p ->> Point 0 1, p ->> Point 1 0]

isAdjacent :: Blueprint -> Point -> Point -> Bool
isAdjacent b p q = q `Prelude.elem` adjacentPoints b p

-- Convert a blueprint to a graph
blueprintToGraph :: Blueprint -> Graph
blueprintToGraph b@Blueprint {grid = g} = Graph $ Map.fromList $ Prelude.map toEdge (allPoints b)
  where
    toEdge p = (pointToInt b p, Set.fromList $ Prelude.map (pointToInt b) (openAdjacentPoints p))
    isOpen p p' = case Map.lookup p' g of
      Nothing -> True
      Just (Wire t) -> case p ->> p' of
        Point x 0 | abs x == 1 -> not (connectsToEast t || connectsToWest t)
        Point 0 y | abs y == 1 -> not (connectsToNorth t || connectsToSouth t)
        _ -> error "Non-adjacent point passed to isOpen"
      _ -> False
    openAdjacentPoints p = Prelude.filter (isOpen p) (adjacentPoints b p)

-- | A utility function to convert a map of parents (generated by traversal) into a graph
processTraversal :: Int -> Map Int Int -> Graph
processTraversal x = Graph . Map.insert x Set.empty . Map.map Set.singleton

-- | Run a dfs on a tree, producing a map from children to parents
--     graph    root   parents        updated parents
dfs :: Graph -> Int -> Map Int Int -> Map Int Int
dfs g x parents = Prelude.foldr aux parents (children g [x])
  where
    aux child parents' =
      if child `Map.member` parents'
        then parents'
        else dfs g child (Map.insert child x parents')

-- | Runs a dfs on the graph starting from the specified node.
-- The resulting graph will be the transpose of the dfs tree
dfsFrom :: Graph -> Int -> Graph
dfsFrom g x = processTraversal x $ dfs g x Map.empty

-- | Run a bfs on a tree, producing a map from children to parents
--     graph     queue   parents        updated parents
bfs :: Graph -> [Int] -> Map Int Int -> Map Int Int
bfs _ [] parents = parents
bfs g xs parents = bfs g xs' parents'
  where
    xs' = Prelude.filter (`Map.notMember` parents) $ children g xs
    parents' = Prelude.foldr addChildrenToParents parents xs
    addChildrenToParents x m = Prelude.foldr (`insertIfNew` x) m (children g [x])

-- | Runs a bfs on the graph starting from the specified node.
-- The resulting graph will be the transpose of the bfs tree
bfsFrom :: Graph -> Int -> Graph
bfsFrom g x = processTraversal x $ bfs g [x] Map.empty

-- | Given a graph and a list of nodes,
-- | return the list of all children of nodes in the list.
children :: Graph -> [Int] -> [Int]
children (Graph m) ys = Set.toList $ Set.unions (Maybe.mapMaybe (`Map.lookup` m) ys)

-- | Utility to insert a pair into a map iff the key doesn't exist
insertIfNew :: Ord k => k -> a -> Map k a -> Map k a
insertIfNew x y m = if x `Map.member` m then m else Map.insert x y m

-- Checks whether the specified node exists in the graph
elem :: Int -> Graph -> Bool
elem x (Graph m) = x `Map.member` m || x `Set.member` Set.unions (Map.elems m)

-- | Returns a set of all vertices in the graph
elems :: Graph -> Set Int
elems (Graph m) = Map.keysSet m `Set.union` Set.unions (Map.elems m)

-- | Checks whether the first graph is a subgraph of the second
-- (i.e. that all vertices and edges in the first exist in the second)
isSubgraph :: Graph -> Graph -> Bool
isSubgraph (Graph m1) (Graph m2) = all p (Map.keys m1)
  where
    p x = case Map.lookup x m2 of
      Nothing -> False
      Just s -> fromJust (Map.lookup x m1) `isSubsetOf` s

-- | Reverse the direction of all the edges in a graph
transpose :: Graph -> Graph
transpose g@(Graph m) = Graph $ Set.fromList <$> Set.foldr aux (Map.map (const []) m) (GraphUtils.elems g)
  where
    aux x m' = case Map.lookup x m of
      Nothing -> m'
      Just s -> Set.foldr (\x' m' -> Map.insertWith (++) x' [x] m') m' s

-- | Find the path between two points in the transpose of a bfs tree, if it exists.
-- Expects, but does not check, that the given graph is transpose of a bfs tree.
(~>) :: Int -> Int -> Graph -> Maybe [Int]
x ~> y = \(Graph m) -> reverse <$> path x y m
  where
    path p q m = case Map.lookup q m of
      Nothing -> Nothing
      Just s -> case Set.toList s of
        [p'] | p' == p -> Just [q, p]
        [p'] -> do
          xs' <- path p p' m
          Just $ q : xs'
        [] -> Nothing
        _ -> error $ "The provided graph is not a transpose of a bfs tree: " ++ show m